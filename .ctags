--langdef=julia
--langmap=julia:.jl
--regex-julia=/^[ \t]*(@with_kw[ \t]+)?(abstract type|primitive type|struct|mutable struct|typealias)[ \t]+([^ \t({[]+).*$/\3/t,type/
--regex-julia=/^[ \t]*(macro)[ \t]+([^ \t({[]+).*$/\2/m,macro/
--regex-julia=/^[ \t]*(@inline[ \t]+|@noinline[ \t]+)?(function)[ \t]+([^ \t({[]+)[^(]*\([ \t]*([^ \t;,=)({]+).*$/\3 (\4, …)/f,function/
--regex-julia=/^[ \t]*(@inline[ \t]+|@noinline[ \t]+)?(function)[ \t]+([^ \t({[]+)[^(]*(\([ \t]*\).*|\([ \t]*)$/\3/f,function/
--regex-julia=/^[ \t]*(@inline[ \t]+|@noinline[ \t]+)?(([^@#$ \t({[]+)|\(([^@#$ \t({[]+)\)|\((\$)\))[ \t]*(\{.*\})?[ \t]*\([ \t]*\)[ \t]*=([^=].*$|$)/\3\4\5/f,function/
--regex-julia=/^[ \t]*(@inline[ \t]+|@noinline[ \t]+)?(([^@#$ \t({[]+)|\(([^@#$ \t({[]+)\)|\((\$)\))[ \t]*(\{.*\})?[ \t]*\([ \t]*([^ \t;,=)({]+).*\)[ \t]*=([^=].*$|$)/\3\4\5 (\7, …)/f,function/
--regex-julia=/^(const)[ \t]+([^ \t({[]+).*[ ]*=.*$/\2/c,const/

--regex-make=/^([^# \t:]*):/\1/t,target/

--langdef=nim
--langmap=nim:.nim
--regex-nim=/(\w+)\*?\s*=\s*object/\1/c,class/
--regex-nim=/(\w+)\*?\s*=\s*enum/\1/e,enum/
--regex-nim=/(\w+)\*?\s*=\s*tuple/\1/t,tuple/
--regex-nim=/(\w+)\*?\s*=\s*range/\1/r,subrange/
--regex-nim=/(\w+)\*?\s*=\s*proc/\1/P,proctype/
--regex-nim=/proc\s+(\w+)/\1/p,procedure/
--regex-nim=/method\s+(\w+)/\1/m,method/
--regex-nim=/proc\s+`([^`]+)`/\1/o,operator/
--regex-nim=/template\s+(\w+)/\1/T,template/
--regex-nim=/macro\s+(\w+)/\1/M,macro/

--langdef=Zig
--langmap=Zig:.zig
--regex-Zig=/fn +([a-zA-Z0-9_]+) *\(/\1/f,functions,function definitions/
--regex-Zig=/(var|const) *([a-zA-Z0-9_]+) *= *(extern|packed)? *struct/\2/s,structs,struct definitions/
--regex-Zig=/(var|const) *([a-zA-Z0-9_]+) *= *(extern|packed)? *enum/\2/e,enums,enum definitions/
--regex-Zig=/(var|const) *([a-zA-Z0-9_]+) *= *(extern|packed)? *union/\2/u,unions,union definitions/
--regex-Zig=/(var|const) *([a-zA-Z0-9_]+) *= *error/\2/E,errors,error definitions/
